<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态代理</title>
    <url>/2020/10/09/dong-tai-dai-li/</url>
    <content><![CDATA[<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>spring aop 默认使用的是JDK动态代理。如果一个类实现了一个接口，则spring则会用这种方式进行代理。<br>首先是实现InvocationHandler接口， 重写invoke方法， 这个方法就是代理的方法。其次是Proxy类，通过这个类的newProxyInstance方法， 返回一个代理对象。生成的代理对象实现原来那个类的所有接口， 并对接口的方法进行代理 ， 通过代理对象调用这些方法，底层通过反射实现， 调用我们实现的invoke方法。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>原生， 不需要任何依赖。</p>
<p>通过反射机制生成的代理类的速度比CGLib操作字节码生成的代理类的速度更快。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>被代理的类必须继承一个或多个接口，否则无法代理。</p>
<p>无法为没有在接口中定义的方法实现代理。</p>
<p>代理方法时， 需要通过反射机制进行回调， 此时执行效率比较低。</p>
<h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>直接操作字节码， 生成类的自乐，重写类的方法完成代理。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>被代理的类不需要实现接口，代理类可以直接继承被代理的类。</p>
<p>被代理的类是原来那个类的子类，所以能够被子类重写的方法都可以进行代理。</p>
<p>代理效率高于JDK的动态代理。</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>无法代理Final类。</p>
<p>无法对final方法， private方法进行代理。</p>
<p>通过字节码生成代理类，其速度要低于JDK通过反射生成代理类的速度。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>定义接口：</p>
<pre class=" language-Java"><code class="language-Java">public interface Star &#123;

    void sing(String name);

    void dance(String name);
&#125;
</code></pre>
<p>接口实现类</p>
<pre class=" language-Java"><code class="language-Java">public class Ll implements Star &#123;

    public final void info()&#123;
        System.out.println("info");
    &#125;

    @Override
    public void sing(String name) &#123;
        System.out.println(name + " "+ "sing");
    &#125;

    @Override
    public void dance(String name) &#123;
        System.out.println(name + " "+ "dance");
    &#125;
&#125;</code></pre>
<p>JDK动态代理：</p>
<pre class=" language-Java"><code class="language-Java">public class StarProxy implements InvocationHandler &#123;

    //目标类
    private Object object;

    public void setObject(Object object) &#123;
        this.object = object;
    &#125;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println("earn money"); //增强
        method.invoke(object, args);
        return null;
    &#125;

    //生成代理类
    public Object createProxyObject()&#123;
        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);
    &#125;
&#125;</code></pre>
<p>cglib动态代理：</p>
<pre class=" language-Java"><code class="language-Java">public class CglibProxy implements MethodInterceptor &#123;

    //产生一个代理类
    public Object createProxyObject(Class<?> clazz)&#123;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    &#125;

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        System.out.println("earn money");
        return methodProxy.invokeSuper(o, objects);
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre class=" language-Java"><code class="language-Java">public class JdkProxyDemo &#123;

    public static void main(String[] args) &#123;
        Star star = new Ll();
        StarProxy starProxy = new StarProxy();
        starProxy.setObject(star);
        Object proxyObject = starProxy.createProxyObject();
        Star proxyStar = (Star)proxyObject;
        proxyStar.dance("aa");
    &#125;
    //代理类不能直接包含被代理的对象， 而是一个InvocationHandler, InvocationHandler包含被代理的对象， 并负责分发请求给代理对象， 分发前后都可以做增强
&#125;</code></pre>
<pre class=" language-Java"><code class="language-Java">public class CglibDemo &#123;

    public static void main(String[] args) &#123;
        CglibProxy cglibProxy = new CglibProxy();
        Ll star = (Ll) cglibProxy.createProxyObject(Ll.class);
        star.sing("bb");
        star.dance("cc");
        star.info();//因为info是final ，所以无法被代理
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解volatile关键字</title>
    <url>/2020/10/08/shen-ru-li-jie-volatile-guan-jian-zi/</url>
    <content><![CDATA[<h3 id="机器硬件CPU"><a href="#机器硬件CPU" class="headerlink" title="机器硬件CPU"></a>机器硬件CPU</h3><p>所有的运算操作都是交由CPU寄存器来完成的，操作指令需要数据的读取和写入，而所有数据来源是计算机的主存，但是内存的访问速度远远不及CPU的运算速度。由于两边严重不对等，传统的FSB直连内存的访问方式会严重影响整体的吞吐量，所以增加了缓存设计。现在的缓存增加到了3级， 最靠近CPU的缓存为L1，然后依次为L2， L3，和主内存。<br>L1 cache 又分为 l1d和l1i, 这两种有各自专门的用途。CPU cache有多个Cache Line构成， 大小为64字节， 也是最小的缓存单位。</p>
<h4 id="CPU缓存一致性问题"><a href="#CPU缓存一致性问题" class="headerlink" title="CPU缓存一致性问题"></a>CPU缓存一致性问题</h4><p>每个线程都有自己的工作内存， 变量在多个线程的本地内存中都存在自己的副本。如果两个线程同时对变量执行操作如i++，然后再经过计算写入主内存， 很有可能经过两次操作，结果还是1。</p>
<p>1 通过总线加锁的方式</p>
<p>每次只有一个CPU能够访问变量的内存，效率低下。</p>
<p>2 通过缓存一致性协议(如Intel的MESI协议)</p>
<p>读取操作，不做任何处理， 只是将Cache中的数据读取到寄存器当中。写入操作， 发出信号通知其他CPU将该变量的Cache line设置为无效状态， 然后在变量进行读取的时候到主存中再次获取。</p>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><h4 id="线程和内存的抽象关系"><a href="#线程和内存的抽象关系" class="headerlink" title="线程和内存的抽象关系"></a>线程和内存的抽象关系</h4><ol>
<li><p>共享变量存储于主内存之中， 每个线程都可以访问。</p>
</li>
<li><p>每个线程都有私有的工作内存或者本地内存。</p>
</li>
<li><p>工作内存只是存储对共享变量的副本。</p>
</li>
<li><p>线程不能直接操作主内存， 只有先操作了工作内存之后才能写入到主内存。</p>
</li>
</ol>
<h4 id="原子性，-可见性，-有序性"><a href="#原子性，-可见性，-有序性" class="headerlink" title="原子性， 可见性， 有序性"></a>原子性， 可见性， 有序性</h4><ol>
<li>java内存模型只保证了读取和赋值的原子性操作， 其他都不保证。如果要使某些代码片段具备原子性， 需要使用synchronzied, 或者JUC中lock， volatile无法保证原子性</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileDemo</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        t<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<ol start="2">
<li><p>volatile， synchronized， 和显示锁Lock均能保证可见性。</p>
</li>
<li><p>单线程的情况下， 重排序并不会引起什么问题。在多线程的情况下， 会影响到程序的正确执行， 同样通过volatile， synchronized， 和显示锁Lock保证有序性。</p>
</li>
</ol>
<p><em>java内存模型通过Happens-before原则就可以保证有序性</em></p>
<h3 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h3><p>unsafe.cpp源码中，被volatile修饰的变量存在于一个 “lock;” 的前缀， 相当于一个内存屏障。</p>
<ol>
<li><p>该屏障保证指令重排序不会被后面的代码排到内存屏障之前。</p>
</li>
<li><p>该屏障保证指令重排序不会被前面的代码排到内存屏障之后。</p>
</li>
<li><p>该屏障确保屏障之前的指令前面的代码全部执行完成。</p>
</li>
<li><p>强制将线程工作内存中的值修改刷新到主内存当中。</p>
</li>
<li><p>如果是写操作， 则会导致其他线程工作内存中缓存数据失效。</p>
</li>
</ol>
<h3 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h3><ol>
<li><p>开关控制利用可见效， 常见的就是线程的关闭操作。</p>
</li>
<li><p>状态标记利用有序性。</p>
</li>
<li><p>单例模式的double-check利用有序性</p>
</li>
</ol>
<h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ol>
<li><p>volatile只能修饰实例变量和类变量， 不能修饰方法和方法参数，及局部变量，常量。</p>
</li>
<li><p>synchronized 不能修饰变量，只能修饰方法和代码块。</p>
</li>
<li><p>volatile修饰的变量可以为null， 但是synchronzied的monitor对象不能为null。</p>
</li>
<li><p>volatile无法保证原子性， 但是synchronized是一种排他机制， 因此能够保证原子性。</p>
</li>
<li><p>两种都可以保证共享资源在多线程间可见，但是实现机制不同。 synchronized借助JVM指令的monitor enter和monitor exit对通过排他对方式使得代码串行化， 在monitor exit时对共享资源都会刷新都主内存当中。而volatile使用机器指令”lock;” 的方式迫使其他线程工作内存的数据失效，不得到主内存进行再次加载。</p>
</li>
<li><p>volatile禁止JVM编译器以及处理器对其进行重排序， 所以能够保证有序性。synchronized以程序的串行化执行来交换的。</p>
</li>
<li><p>volatile不会使线程陷入阻塞， synchronized会使线程陷入阻塞。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>内存</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized关键字总结</title>
    <url>/2020/10/07/synchronized-guan-jian-zi-zong-jie/</url>
    <content><![CDATA[<h3 id="什么是synchronized"><a href="#什么是synchronized" class="headerlink" title="什么是synchronized"></a>什么是synchronized</h3><p>synchronized 关键字可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对对象对所有读和写都将通过同步对方式来进行。</p>
<p>提供了一种锁对机制，能够确保共享变量对互斥访问，从而防止数据不一致的问题</p>
<p>包括monitor enter和monitor exit两个JVM指令， 能够保证在任何时候任何线程执行到monitor enter成功前都必须从主存中获取数据，而不是从缓存中， 在monitor exit运行成功后，共享变量被更新后的值必须刷入到主内存当中</p>
<p>严格遵守happens-before规则， 一个monitor exit指令之前必须要有一个monitor enter指令</p>
<h3 id="synchronized-的使用"><a href="#synchronized-的使用" class="headerlink" title="synchronized 的使用"></a>synchronized 的使用</h3><p>1 同步方法</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>2 同步代码块</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object MUTEX <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>MUTEX<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> Mutex mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mutex<span class="token operator">:</span><span class="token operator">:</span>access<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

</code></pre>
<h3 id="线程堆栈分析"><a href="#线程堆栈分析" class="headerlink" title="线程堆栈分析"></a>线程堆栈分析</h3><p>使用Jconsole工具连接，监控JVM线程</p>
<p>使用jstack命令打印进程的线程堆栈信息</p>
<h3 id="synchronized-的底层原理"><a href="#synchronized-的底层原理" class="headerlink" title="synchronized 的底层原理"></a>synchronized 的底层原理</h3><p>使用javap命令对java类进行反汇编， 输出大量JVM命令，在这些命令中，你会发现monitor enter和monitor exit是成对出现的。</p>
<ol>
<li><p>monitor enter</p>
<p>每一个对象都与一个monitor关联， 一个monitor的锁只能被一个线程在同一时间获得。所以如果monitor的计数器为0，则意味着monitor的lock还没有被获得，某个线程获得之后会立即对该计数器加一，这个时候该线程就是该monitor的所有者。如果一个已经拥有该monitor的所有权的线程重如，则会导致计数器再次累加。如果monitor已经被其他线程所拥有， 则其他线程尝试获取该monitor的所有权，会被陷入阻塞状态直到monitor计数器变为0，才能再次尝试获取对monitor对所有权。</p>
</li>
<li><p>monitor exit</p>
<p>释放对monitor对所有权， 将计数器减一。</p>
</li>
<li><p>this monitor</p>
<p>如果一个类中多个方法都被syncronized修饰，争抢的是同一个monitor的lock。</p>
</li>
<li><p>class monitor</p>
<p>如果一个类多个静态方法都被syncronized修饰，同样也是争抢的同一个monitor的lock。</p>
</li>
</ol>
<h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><p>1 与monitor关联的对象不能为null</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> Object mutex <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>2 作用域太大， 其效率越低</p>
<p>3 不同的monitor企图锁相同的方法</p>
<p>4 多个锁交叉导致死锁</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList使用和分析</title>
    <url>/2020/09/21/arraylist-shi-yong-he-fen-xi/</url>
    <content><![CDATA[<h3 id="ArrayList的框架"><a href="#ArrayList的框架" class="headerlink" title="ArrayList的框架"></a>ArrayList的框架</h3><ul>
<li><p>继承AbstractList抽象类（ AbstractList -&gt; AbstractCollection -&gt; Collection）</p>
</li>
<li><p>实现List接口 （List -&gt; Collection -&gt; Iterable）</p>
</li>
<li><p>实现RandomAccess接口（随机访问，通过元素的序号获取元素）</p>
</li>
<li><p>实现Cloneable接口（能被复制克隆）</p>
</li>
<li><p>实现java.io.Serializable接口（可以序列化传输）</p>
</li>
</ul>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList 相当于一个动态数组，容量动态增长。初识容量0，第一次扩容的大小为10，每次扩容后的大小是之前的1.5倍。在实际的操作中，它不是线程安全的容器，因此在多线程中应该选择Vector或者CopyOnWriteArrayList。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre class=" language-Java"><code class="language-Java">// 默认构造函数
ArrayList()

// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。
ArrayList(int capacity)

// 创建一个包含collection的ArrayList
ArrayList(Collection<? extends E> collection)</code></pre>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li><p>迭代器</p>
</li>
<li><p>索引</p>
</li>
<li><p>for循环</p>
</li>
</ol>
<p>** 效率由高到低 **  索引 》 for循环 = 迭代器</p>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p><strong>Java不支持向下转型</strong></p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> stringList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> stringList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> array2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>stringList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
stringList<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
</search>
